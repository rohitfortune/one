<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/build.gradle.kts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/build.gradle.kts" />
              <option name="originalContent" value="plugins {&#10;    alias(libs.plugins.android.application)&#10;    alias(libs.plugins.kotlin.android)&#10;    alias(libs.plugins.ksp)&#10;}&#10;&#10;android {&#10;    namespace = &quot;com.rohit.one&quot;&#10;    compileSdk = 35 &#10;&#10;    defaultConfig {&#10;        applicationId = &quot;com.rohit.one&quot;&#10;        minSdk = 26 &#10;        targetSdk = 35 &#10;        versionCode = 1&#10;        versionName = &quot;1.0&quot;&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_1_8 &#10;        targetCompatibility = JavaVersion.VERSION_1_8&#10;    }&#10;    kotlinOptions {&#10;        jvmTarget = &quot;1.8&quot; &#10;    }&#10;    buildFeatures {&#10;        compose = true&#10;    }&#10;    composeOptions {&#10;        kotlinCompilerExtensionVersion = libs.versions.composeCompiler.get()&#10;    }&#10;}&#10;&#10;dependencies {&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.lifecycle.runtime.ktx)&#10;    implementation(libs.androidx.activity.compose)&#10;    implementation(platform(libs.androidx.compose.bom))&#10;    implementation(libs.androidx.compose.ui)&#10;    implementation(libs.androidx.compose.ui.graphics)&#10;    implementation(libs.androidx.compose.ui.tooling.preview)&#10;    implementation(libs.androidx.compose.material3)&#10;    implementation(libs.androidx.compose.material3.adaptive.navigation.suite)&#10;    implementation(libs.androidx.navigation.compose)&#10;    implementation(libs.androidx.room.runtime)&#10;    implementation(libs.androidx.room.ktx)&#10;    ksp(libs.androidx.room.compiler)&#10;    implementation(libs.androidx.compose.material.icons.extended)&#10;&#10;    // Jetpack Security for encrypted storage (MasterKey/Crypto) used by Passwords feature&#10;    implementation(&quot;androidx.security:security-crypto:1.1.0&quot;)&#10;&#10;    // Biometric authentication for revealing passwords securely&#10;    implementation(&quot;androidx.biometric:biometric:1.1.0&quot;)&#10;&#10;    testImplementation(libs.junit)&#10;    androidTestImplementation(libs.androidx.junit)&#10;    androidTestImplementation(libs.androidx.espresso.core)&#10;    androidTestImplementation(platform(libs.androidx.compose.bom))&#10;    androidTestImplementation(libs.androidx.compose.ui.test.junit4)&#10;    debugImplementation(libs.androidx.compose.ui.tooling)&#10;    debugImplementation(libs.androidx.compose.ui.test.manifest)&#10;}" />
              <option name="updatedContent" value="plugins {&#10;    alias(libs.plugins.android.application)&#10;    alias(libs.plugins.kotlin.android)&#10;    alias(libs.plugins.ksp)&#10;}&#10;&#10;android {&#10;    namespace = &quot;com.rohit.one&quot;&#10;    compileSdk = 35 &#10;&#10;    defaultConfig {&#10;        applicationId = &quot;com.rohit.one&quot;&#10;        minSdk = 26 &#10;        targetSdk = 35 &#10;        versionCode = 1&#10;        versionName = &quot;1.0&quot;&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_1_8 &#10;        targetCompatibility = JavaVersion.VERSION_1_8&#10;    }&#10;    kotlinOptions {&#10;        jvmTarget = &quot;1.8&quot; &#10;    }&#10;    buildFeatures {&#10;        compose = true&#10;    }&#10;    composeOptions {&#10;        kotlinCompilerExtensionVersion = libs.versions.composeCompiler.get()&#10;    }&#10;}&#10;&#10;dependencies {&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.lifecycle.runtime.ktx)&#10;    implementation(libs.androidx.activity.compose)&#10;    implementation(platform(libs.androidx.compose.bom))&#10;    implementation(libs.androidx.compose.ui)&#10;    implementation(libs.androidx.compose.ui.graphics)&#10;    implementation(libs.androidx.compose.ui.tooling.preview)&#10;    implementation(libs.androidx.compose.material3)&#10;    implementation(libs.androidx.compose.material3.adaptive.navigation.suite)&#10;    implementation(libs.androidx.navigation.compose)&#10;    implementation(libs.androidx.room.runtime)&#10;    implementation(libs.androidx.room.ktx)&#10;    ksp(libs.androidx.room.compiler)&#10;    implementation(libs.androidx.compose.material.icons.extended)&#10;&#10;    // Jetpack Security for encrypted storage (MasterKey/Crypto) used by Passwords feature&#10;    implementation(&quot;androidx.security:security-crypto:1.1.0&quot;)&#10;&#10;    // Biometric authentication for revealing passwords securely&#10;    implementation(&quot;androidx.biometric:biometric:1.1.0&quot;)&#10;&#10;    // Google Sign-In (used to obtain OAuth tokens to talk to Drive appData)&#10;    implementation(&quot;com.google.android.gms:play-services-auth:20.7.0&quot;)&#10;&#10;    // HTTP client for Drive REST calls&#10;    implementation(&quot;com.squareup.okhttp3:okhttp:4.11.0&quot;)&#10;    // JSON parsing&#10;    implementation(&quot;com.squareup.moshi:moshi:1.15.0&quot;)&#10;    implementation(&quot;com.squareup.moshi:moshi-kotlin:1.15.0&quot;)&#10;&#10;    testImplementation(libs.junit)&#10;    androidTestImplementation(libs.androidx.junit)&#10;    androidTestImplementation(libs.androidx.espresso.core)&#10;    androidTestImplementation(platform(libs.androidx.compose.bom))&#10;    androidTestImplementation(libs.androidx.compose.ui.test.junit4)&#10;    debugImplementation(libs.androidx.compose.ui.tooling)&#10;    debugImplementation(libs.androidx.compose.ui.test.manifest)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/rohit/one/MainActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/rohit/one/MainActivity.kt" />
              <option name="originalContent" value="package com.rohit.one&#10;&#10;import android.os.Bundle&#10;import androidx.fragment.app.FragmentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Add&#10;import androidx.compose.material.icons.filled.Folder&#10;import androidx.compose.material.icons.filled.Note&#10;import androidx.compose.material.icons.filled.Password&#10;import androidx.compose.material3.Card&#10;import androidx.compose.material3.FloatingActionButton&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.adaptive.navigationsuite.NavigationSuiteScaffold&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.saveable.rememberSaveable&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.vector.ImageVector&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import androidx.core.content.ContextCompat&#10;import androidx.lifecycle.ViewModelProvider&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import androidx.navigation.NavController&#10;import androidx.navigation.NavType&#10;import androidx.navigation.compose.NavHost&#10;import androidx.navigation.compose.composable&#10;import androidx.navigation.compose.rememberNavController&#10;import androidx.navigation.navArgument&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.biometric.BiometricPrompt&#10;import com.rohit.one.data.Note&#10;import com.rohit.one.data.Password&#10;import com.rohit.one.data.CreditCard&#10;import com.rohit.one.data.NoteDatabase&#10;import com.rohit.one.data.NoteRepository&#10;import com.rohit.one.data.PasswordRepository&#10;import com.rohit.one.data.CreditCardRepository&#10;import com.rohit.one.ui.AddEditNoteScreen&#10;import com.rohit.one.ui.AddEditPasswordScreen&#10;import com.rohit.one.ui.AddEditCardScreen&#10;import com.rohit.one.ui.VaultsScreen&#10;import com.rohit.one.ui.FilesScreen&#10;import com.rohit.one.ui.theme.OneTheme&#10;import com.rohit.one.viewmodel.NotesViewModel&#10;import com.rohit.one.viewmodel.VaultsViewModel&#10;import androidx.navigation.NavBackStackEntry // Added import for NavBackStackEntry&#10;&#10;@Suppress(&quot;DEPRECATION&quot;)&#10;enum class AppDestinations(&#10;    val label: String,&#10;    val icon: ImageVector,&#10;) {&#10;    NOTES(&quot;Notes&quot;, Icons.Filled.Note),&#10;    PASSWORDS(&quot;Vault&quot;, Icons.Filled.Password),&#10;    FILES(&quot;Files&quot;, Icons.Filled.Folder),&#10;}&#10;&#10;class MainActivity : FragmentActivity() {&#10;&#10;    private lateinit var notesViewModel: NotesViewModel&#10;    private lateinit var vaultsViewModel: VaultsViewModel&#10;&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        enableEdgeToEdge()&#10;&#10;        val database = NoteDatabase.getDatabase(applicationContext)&#10;        val repository = NoteRepository(database.noteDao())&#10;        // Use ViewModelProvider here because viewModel() is a @Composable and cannot be called from onCreate&#10;        notesViewModel = ViewModelProvider(this, NotesViewModel.provideFactory(repository))[NotesViewModel::class.java]&#10;&#10;        // Vaults (passwords + cards) repository &amp; ViewModel&#10;        val passwordRepository = PasswordRepository(database.passwordDao(), applicationContext)&#10;        val cardRepository = CreditCardRepository(database.creditCardDao(), applicationContext)&#10;        vaultsViewModel = ViewModelProvider(this, VaultsViewModel.provideFactory(passwordRepository, cardRepository))[VaultsViewModel::class.java]&#10;&#10;        setContent {&#10;            OneTheme {&#10;                OneApp(notesViewModel = notesViewModel, vaultsViewModel = vaultsViewModel)&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun OneApp(&#10;    notesViewModel: NotesViewModel = viewModel(),&#10;    vaultsViewModel: VaultsViewModel = viewModel()&#10;) {&#10;    val navController = rememberNavController()&#10;&#10;    NavHost(navController = navController, startDestination = &quot;main&quot;) {&#10;        composable(route = &quot;main&quot;) {&#10;            MainScreen(&#10;                onNavigateToAddNote = { navController.navigate(&quot;addEditNote/-1&quot;) },&#10;                onNavigateToEditNote = { noteId -&gt; navController.navigate(&quot;addEditNote/$noteId&quot;) },&#10;                onNavigateToAddPassword = { navController.navigate(&quot;addEditPassword/-1&quot;) },&#10;                onNavigateToEditPassword = { pwId -&gt; navController.navigate(&quot;addEditPassword/$pwId&quot;) },&#10;                onNavigateToAddCard = { navController.navigate(&quot;addEditCard/-1&quot;) },&#10;                onNavigateToEditCard = { cardId -&gt; navController.navigate(&quot;addEditCard/$cardId&quot;) },&#10;                notesViewModel = notesViewModel,&#10;                vaultsViewModel = vaultsViewModel&#10;            )&#10;        }&#10;        composable(&#10;            route = &quot;addEditNote/{noteId}&quot;,&#10;            arguments = listOf(navArgument(&quot;noteId&quot;) { type = NavType.IntType })&#10;        ) { backStackEntry -&gt;&#10;            AddEditNoteRoute(&#10;                navController = navController,&#10;                notesViewModel = notesViewModel,&#10;                backStackEntry = backStackEntry&#10;            )&#10;        }&#10;        composable(&#10;            route = &quot;addEditPassword/{pwId}&quot;,&#10;            arguments = listOf(navArgument(&quot;pwId&quot;) { type = NavType.IntType })&#10;        ) { backStackEntry -&gt;&#10;            AddEditPasswordRoute(&#10;                navController = navController,&#10;                vaultsViewModel = vaultsViewModel,&#10;                backStackEntry = backStackEntry&#10;            )&#10;        }&#10;        composable(&#10;            route = &quot;addEditCard/{cardId}&quot;,&#10;            arguments = listOf(navArgument(&quot;cardId&quot;) { type = NavType.IntType })&#10;        ) { backStackEntry -&gt;&#10;            AddEditCardRoute(&#10;                navController = navController,&#10;                vaultsViewModel = vaultsViewModel,&#10;                backStackEntry = backStackEntry&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun AddEditPasswordRoute(&#10;    navController: NavController,&#10;    vaultsViewModel: VaultsViewModel,&#10;    backStackEntry: NavBackStackEntry&#10;) {&#10;    val pwId = backStackEntry.arguments?.getInt(&quot;pwId&quot;)&#10;    val pwToEdit = vaultsViewModel.passwords.collectAsState().value.find { it.id == pwId }&#10;    val context = LocalContext.current&#10;&#10;    // requestRawPassword: caller will trigger biometric auth and then receive the secret via callback&#10;    val requestRawPassword: (((String?) -&gt; Unit) -&gt; Unit)? = pwToEdit?.let { pw -&gt;&#10;        { onResult -&gt;&#10;            // pw is non-null here (let scope). Proceed to prompt for biometric auth and return secret via onResult.&#10;            val executor = ContextCompat.getMainExecutor(context)&#10;            val promptInfo = BiometricPrompt.PromptInfo.Builder()&#10;                .setTitle(&quot;Authenticate&quot;)&#10;                .setSubtitle(&quot;Authenticate to reveal password&quot;)&#10;                .setNegativeButtonText(&quot;Cancel&quot;)&#10;                .build()&#10;            val biometricPrompt = BiometricPrompt(context as FragmentActivity, executor,&#10;                object : BiometricPrompt.AuthenticationCallback() {&#10;                    override fun onAuthenticationSucceeded(result: BiometricPrompt.AuthenticationResult) {&#10;                        super.onAuthenticationSucceeded(result)&#10;                        onResult(vaultsViewModel.getRawPassword(pw.uuid))&#10;                    }&#10;&#10;                    override fun onAuthenticationError(errorCode: Int, errString: CharSequence) {&#10;                        super.onAuthenticationError(errorCode, errString)&#10;                        onResult(null)&#10;                    }&#10;&#10;                    override fun onAuthenticationFailed() {&#10;                        super.onAuthenticationFailed()&#10;                        onResult(null)&#10;                    }&#10;                })&#10;            biometricPrompt.authenticate(promptInfo)&#10;        }&#10;    }&#10;&#10;    AddEditPasswordScreen(&#10;        password = pwToEdit,&#10;        onSave = { title, username, rawPassword -&gt;&#10;            if (pwToEdit == null) {&#10;                vaultsViewModel.addPassword(title, username, rawPassword)&#10;            } else {&#10;                vaultsViewModel.updatePassword(pwToEdit.copy(title = title, username = username), if (rawPassword.isBlank()) null else rawPassword)&#10;            }&#10;            navController.popBackStack()&#10;        },&#10;        onDelete = { pw -&gt;&#10;            vaultsViewModel.deletePassword(pw)&#10;            navController.popBackStack()&#10;        },&#10;        onNavigateUp = { navController.popBackStack() },&#10;        requestRawPassword = requestRawPassword&#10;    )&#10;}&#10;&#10;@Composable&#10;fun AddEditCardRoute(&#10;    navController: NavController,&#10;    vaultsViewModel: VaultsViewModel,&#10;    backStackEntry: NavBackStackEntry&#10;) {&#10;    val cardId = backStackEntry.arguments?.getInt(&quot;cardId&quot;)&#10;    val cardToEdit = vaultsViewModel.cards.collectAsState().value.find { it.id == cardId }&#10;    val context = LocalContext.current&#10;&#10;    val requestFullNumber: (((String?) -&gt; Unit) -&gt; Unit)? = cardToEdit?.let { card -&gt;&#10;        { onResult -&gt;&#10;            val executor = ContextCompat.getMainExecutor(context)&#10;            val promptInfo = BiometricPrompt.PromptInfo.Builder()&#10;                .setTitle(&quot;Authenticate&quot;)&#10;                .setSubtitle(&quot;Authenticate to reveal card number&quot;)&#10;                .setNegativeButtonText(&quot;Cancel&quot;)&#10;                .build()&#10;            val biometricPrompt = BiometricPrompt(context as FragmentActivity, executor,&#10;                object : BiometricPrompt.AuthenticationCallback() {&#10;                    override fun onAuthenticationSucceeded(result: BiometricPrompt.AuthenticationResult) {&#10;                        super.onAuthenticationSucceeded(result)&#10;                        onResult(vaultsViewModel.getFullNumber(card.uuid))&#10;                    }&#10;&#10;                    override fun onAuthenticationError(errorCode: Int, errString: CharSequence) {&#10;                        super.onAuthenticationError(errorCode, errString)&#10;                        onResult(null)&#10;                    }&#10;&#10;                    override fun onAuthenticationFailed() {&#10;                        super.onAuthenticationFailed()&#10;                        onResult(null)&#10;                    }&#10;                })&#10;            biometricPrompt.authenticate(promptInfo)&#10;        }&#10;    }&#10;&#10;    AddEditCardScreen(&#10;        card = cardToEdit,&#10;        onSave = { name, fullNumber, brand -&gt;&#10;            if (cardToEdit == null) {&#10;                vaultsViewModel.addCard(name, fullNumber, brand)&#10;            } else {&#10;                vaultsViewModel.updateCard(cardToEdit.copy(cardholderName = name, brand = brand), if (fullNumber.isBlank()) null else fullNumber)&#10;            }&#10;            navController.popBackStack()&#10;        },&#10;        onDelete = { c -&gt;&#10;            vaultsViewModel.deleteCard(c)&#10;            navController.popBackStack()&#10;        },&#10;        onNavigateUp = { navController.popBackStack() },&#10;        onRequestFullNumber = requestFullNumber&#10;    )&#10;}&#10;&#10;@Composable&#10;fun MainScreen(&#10;    onNavigateToAddNote: () -&gt; Unit,&#10;    onNavigateToEditNote: (Int) -&gt; Unit,&#10;    onNavigateToAddPassword: () -&gt; Unit,&#10;    onNavigateToEditPassword: (Int) -&gt; Unit,&#10;    onNavigateToAddCard: () -&gt; Unit,&#10;    onNavigateToEditCard: (Int) -&gt; Unit,&#10;    notesViewModel: NotesViewModel,&#10;    vaultsViewModel: VaultsViewModel&#10;) {&#10;    // Specify type parameter explicitly to help inference&#10;    var currentDestination by rememberSaveable { mutableStateOf&lt;AppDestinations&gt;(AppDestinations.NOTES) }&#10;&#10;    NavigationSuiteScaffold(&#10;        navigationSuiteItems = {&#10;            AppDestinations.entries.forEach {&#10;                item(&#10;                    icon = {&#10;                        Icon(&#10;                            it.icon,&#10;                            contentDescription = it.label&#10;                        )&#10;                    },&#10;                    label = { Text(it.label) },&#10;                    selected = it == currentDestination,&#10;                    onClick = { currentDestination = it }&#10;                )&#10;            }&#10;        }&#10;    ) {&#10;        Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding -&gt;&#10;            when (currentDestination) {&#10;                AppDestinations.NOTES -&gt; NotesScreen(&#10;                    modifier = Modifier.padding(innerPadding),&#10;                    notesViewModel = notesViewModel,&#10;                    onAddNoteClicked = onNavigateToAddNote,&#10;                    onNoteClicked = onNavigateToEditNote&#10;                )&#10;                AppDestinations.PASSWORDS -&gt; VaultsScreen(&#10;                    modifier = Modifier.padding(innerPadding),&#10;                    vaultsViewModel = vaultsViewModel,&#10;                    onAddPassword = onNavigateToAddPassword,&#10;                    onAddCard = onNavigateToAddCard,&#10;                    onPasswordClick = { pw -&gt; onNavigateToEditPassword(pw.id) },&#10;                    onCardClick = { card -&gt; onNavigateToEditCard(card.id) }&#10;                )&#10;                AppDestinations.FILES -&gt; FilesScreen(modifier = Modifier.padding(innerPadding))&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun AddEditNoteRoute(&#10;    navController: NavController,&#10;    notesViewModel: NotesViewModel,&#10;    backStackEntry: NavBackStackEntry&#10;) {&#10;    val noteId = backStackEntry.arguments?.getInt(&quot;noteId&quot;)&#10;    val noteToEdit = notesViewModel.notes.collectAsState().value.find { it.id == noteId }&#10;&#10;    AddEditNoteScreen(&#10;        note = noteToEdit,&#10;        onSave = { note -&gt;&#10;            if (noteToEdit == null) {&#10;                notesViewModel.addNote(note)&#10;            } else {&#10;                notesViewModel.updateNote(note.copy(id = noteToEdit.id))&#10;            }&#10;            navController.popBackStack()&#10;        },&#10;        onDelete = { note -&gt;&#10;            notesViewModel.deleteNote(note)&#10;            navController.popBackStack()&#10;        },&#10;        onNavigateUp = { navController.popBackStack() }&#10;    )&#10;}&#10;&#10;&#10;@Composable&#10;fun NotesScreen(&#10;    modifier: Modifier = Modifier,&#10;    notesViewModel: NotesViewModel,&#10;    onAddNoteClicked: () -&gt; Unit,&#10;    onNoteClicked: (Int) -&gt; Unit&#10;) {&#10;    val notes by notesViewModel.notes.collectAsState()&#10;&#10;    Scaffold(&#10;        modifier = modifier,&#10;        floatingActionButton = {&#10;            FloatingActionButton(onClick = onAddNoteClicked) {&#10;                Icon(Icons.Filled.Add, contentDescription = &quot;Add note&quot;)&#10;            }&#10;        }&#10;    ) { innerPadding -&gt;&#10;        LazyColumn(&#10;            modifier = Modifier&#10;                .padding(innerPadding)&#10;                .padding(16.dp),&#10;            verticalArrangement = Arrangement.spacedBy(8.dp)&#10;        ) {&#10;            items(notes) { note -&gt;&#10;                NoteItem(note, onClick = { onNoteClicked(note.id) })&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun NoteItem(note: Note, onClick: () -&gt; Unit) {&#10;    Card(modifier = Modifier.clickable(onClick = onClick)) {&#10;        Column(modifier = Modifier.padding(16.dp)) {&#10;            Text(text = note.title, style = MaterialTheme.typography.titleMedium)&#10;            Text(text = note.content, style = MaterialTheme.typography.bodyMedium)&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.rohit.one&#10;&#10;import android.app.Activity&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.os.Bundle&#10;import androidx.fragment.app.FragmentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Add&#10;import androidx.compose.material.icons.filled.Folder&#10;import androidx.compose.material.icons.filled.Note&#10;import androidx.compose.material.icons.filled.Password&#10;import androidx.compose.material3.Card&#10;import androidx.compose.material3.FloatingActionButton&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.adaptive.navigationsuite.NavigationSuiteScaffold&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.saveable.rememberSaveable&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.vector.ImageVector&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import androidx.core.content.ContextCompat&#10;import androidx.lifecycle.ViewModelProvider&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import androidx.navigation.NavController&#10;import androidx.navigation.NavType&#10;import androidx.navigation.compose.NavHost&#10;import androidx.navigation.compose.composable&#10;import androidx.navigation.compose.rememberNavController&#10;import androidx.navigation.navArgument&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.biometric.BiometricPrompt&#10;import com.rohit.one.data.Note&#10;import com.rohit.one.data.Password&#10;import com.rohit.one.data.CreditCard&#10;import com.rohit.one.data.NoteDatabase&#10;import com.rohit.one.data.NoteRepository&#10;import com.rohit.one.data.PasswordRepository&#10;import com.rohit.one.data.CreditCardRepository&#10;import com.rohit.one.data.BackupRepository&#10;import com.rohit.one.ui.BackupScreen&#10;import com.google.android.gms.auth.GoogleAuthUtil&#10;import com.google.android.gms.auth.UserRecoverableAuthException&#10;import com.google.android.gms.auth.api.signin.GoogleSignIn&#10;import com.google.android.gms.auth.api.signin.GoogleSignInClient&#10;import com.google.android.gms.auth.api.signin.GoogleSignInOptions&#10;import com.google.android.gms.common.api.Scope&#10;import com.google.android.gms.drive.Drive&#10;import com.google.android.gms.drive.DriveScopes&#10;import com.rohit.one.ui.AddEditNoteScreen&#10;import com.rohit.one.ui.AddEditPasswordScreen&#10;import com.rohit.one.ui.AddEditCardScreen&#10;import com.rohit.one.ui.VaultsScreen&#10;import com.rohit.one.ui.FilesScreen&#10;import com.rohit.one.ui.theme.OneTheme&#10;import com.rohit.one.viewmodel.NotesViewModel&#10;import com.rohit.one.viewmodel.VaultsViewModel&#10;import androidx.navigation.NavBackStackEntry // Added import for NavBackStackEntry&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.withContext&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.MainScope&#10;import kotlinx.coroutines.launch&#10;&#10;@Suppress(&quot;DEPRECATION&quot;)&#10;enum class AppDestinations(&#10;    val label: String,&#10;    val icon: ImageVector,&#10;) {&#10;    NOTES(&quot;Notes&quot;, Icons.Filled.Note),&#10;    PASSWORDS(&quot;Vault&quot;, Icons.Filled.Password),&#10;    FILES(&quot;Files&quot;, Icons.Filled.Folder),&#10;    BACKUP(&quot;Backup&quot;, Icons.Filled.Folder),&#10;}&#10;&#10;class MainActivity : FragmentActivity() {&#10;&#10;    private lateinit var notesViewModel: NotesViewModel&#10;    private lateinit var vaultsViewModel: VaultsViewModel&#10;    private lateinit var googleSignInClient: GoogleSignInClient&#10;    private val mainScope = MainScope()&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        enableEdgeToEdge()&#10;&#10;        val database = NoteDatabase.getDatabase(applicationContext)&#10;        val repository = NoteRepository(database.noteDao())&#10;        notesViewModel = ViewModelProvider(this, NotesViewModel.provideFactory(repository))[NotesViewModel::class.java]&#10;&#10;        val passwordRepository = PasswordRepository(database.passwordDao(), applicationContext)&#10;        val cardRepository = CreditCardRepository(database.creditCardDao(), applicationContext)&#10;        vaultsViewModel = ViewModelProvider(this, VaultsViewModel.provideFactory(passwordRepository, cardRepository))[VaultsViewModel::class.java]&#10;&#10;        // Google Sign-In client for Drive appData scope&#10;        val gso = GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN)&#10;            .requestEmail()&#10;            .requestScopes(Scope(DriveScopes.DRIVE_APPDATA))&#10;            .build()&#10;        googleSignInClient = GoogleSignIn.getClient(this, gso)&#10;&#10;        setContent {&#10;            OneTheme {&#10;                OneApp(notesViewModel = notesViewModel, vaultsViewModel = vaultsViewModel, googleSignInClient = googleSignInClient)&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;suspend fun fetchAccessToken(context: Context, accountName: String?): String? = withContext(Dispatchers.IO) {&#10;    if (accountName == null) return@withContext null&#10;    try {&#10;        val scope = &quot;oauth2:${DriveScopes.DRIVE_APPDATA}&quot;&#10;        return@withContext GoogleAuthUtil.getToken(context, accountName, scope)&#10;    } catch (e: UserRecoverableAuthException) {&#10;        // Caller must handle starting the intent from the exception to get consent&#10;        return@withContext null&#10;    } catch (e: Exception) {&#10;        return@withContext null&#10;    }&#10;}&#10;&#10;@Composable&#10;fun OneApp(&#10;    notesViewModel: NotesViewModel = viewModel(),&#10;    vaultsViewModel: VaultsViewModel = viewModel(),&#10;    googleSignInClient: GoogleSignInClient&#10;) {&#10;    val navController = rememberNavController()&#10;    val context = LocalContext.current&#10;    val activity = context as Activity&#10;&#10;    // Backup repository instance&#10;    val backupRepository = remember { BackupRepository(context.applicationContext) }&#10;&#10;    // Track signed in account&#10;    var signedInAccount by rememberSaveable { mutableStateOf&lt;String?&gt;(GoogleSignIn.getLastSignedInAccount(context)?.account?.name) }&#10;&#10;    // Launcher for sign-in&#10;    val signInLauncher = rememberLauncherForActivityResult(contract = androidx.activity.result.contract.ActivityResultContracts.StartActivityForResult()) { result -&gt;&#10;        val task = GoogleSignIn.getSignedInAccountFromIntent(result.data)&#10;        try {&#10;            val account = task.getResult(Exception::class.java)&#10;            signedInAccount = account?.account?.name&#10;        } catch (_: Exception) {&#10;            signedInAccount = null&#10;        }&#10;    }&#10;&#10;    // access token provider to be passed to BackupScreen&#10;    val accessTokenProvider: suspend () -&gt; String? = {&#10;        fetchAccessToken(context, signedInAccount)&#10;    }&#10;&#10;    NavHost(navController = navController, startDestination = &quot;main&quot;) {&#10;        composable(route = &quot;main&quot;) {&#10;            MainScreen(&#10;                onNavigateToAddNote = { navController.navigate(&quot;addEditNote/-1&quot;) },&#10;                onNavigateToEditNote = { noteId -&gt; navController.navigate(&quot;addEditNote/$noteId&quot;) },&#10;                onNavigateToAddPassword = { navController.navigate(&quot;addEditPassword/-1&quot;) },&#10;                onNavigateToEditPassword = { pwId -&gt; navController.navigate(&quot;addEditPassword/$pwId&quot;) },&#10;                onNavigateToAddCard = { navController.navigate(&quot;addEditCard/-1&quot;) },&#10;                onNavigateToEditCard = { cardId -&gt; navController.navigate(&quot;addEditCard/$cardId&quot;) },&#10;                notesViewModel = notesViewModel,&#10;                vaultsViewModel = vaultsViewModel,&#10;                activity = activity,&#10;                backupRepository = backupRepository,&#10;                accessTokenProvider = accessTokenProvider,&#10;                onSignIn = {&#10;                    val signInIntent: Intent = googleSignInClient.signInIntent&#10;                    signInLauncher.launch(signInIntent)&#10;                }&#10;            )&#10;        }&#10;        composable(&#10;            route = &quot;addEditNote/{noteId}&quot;,&#10;            arguments = listOf(navArgument(&quot;noteId&quot;) { type = NavType.IntType })&#10;        ) { backStackEntry -&gt;&#10;            AddEditNoteRoute(&#10;                navController = navController,&#10;                notesViewModel = notesViewModel,&#10;                backStackEntry = backStackEntry&#10;            )&#10;        }&#10;        composable(&#10;            route = &quot;addEditPassword/{pwId}&quot;,&#10;            arguments = listOf(navArgument(&quot;pwId&quot;) { type = NavType.IntType })&#10;        ) { backStackEntry -&gt;&#10;            AddEditPasswordRoute(&#10;                navController = navController,&#10;                vaultsViewModel = vaultsViewModel,&#10;                backStackEntry = backStackEntry&#10;            )&#10;        }&#10;        composable(&#10;            route = &quot;addEditCard/{cardId}&quot;,&#10;            arguments = listOf(navArgument(&quot;cardId&quot;) { type = NavType.IntType })&#10;        ) { backStackEntry -&gt;&#10;            AddEditCardRoute(&#10;                navController = navController,&#10;                vaultsViewModel = vaultsViewModel,&#10;                backStackEntry = backStackEntry&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun AddEditPasswordRoute(&#10;    navController: NavController,&#10;    vaultsViewModel: VaultsViewModel,&#10;    backStackEntry: NavBackStackEntry&#10;) {&#10;    val pwId = backStackEntry.arguments?.getInt(&quot;pwId&quot;)&#10;    val pwToEdit = vaultsViewModel.passwords.collectAsState().value.find { it.id == pwId }&#10;    val context = LocalContext.current&#10;&#10;    // requestRawPassword: caller will trigger biometric auth and then receive the secret via callback&#10;    val requestRawPassword: (((String?) -&gt; Unit) -&gt; Unit)? = pwToEdit?.let { pw -&gt;&#10;        { onResult -&gt;&#10;            // pw is non-null here (let scope). Proceed to prompt for biometric auth and return secret via onResult.&#10;            val executor = ContextCompat.getMainExecutor(context)&#10;            val promptInfo = BiometricPrompt.PromptInfo.Builder()&#10;                .setTitle(&quot;Authenticate&quot;)&#10;                .setSubtitle(&quot;Authenticate to reveal password&quot;)&#10;                .setNegativeButtonText(&quot;Cancel&quot;)&#10;                .build()&#10;            val biometricPrompt = BiometricPrompt(context as FragmentActivity, executor,&#10;                object : BiometricPrompt.AuthenticationCallback() {&#10;                    override fun onAuthenticationSucceeded(result: BiometricPrompt.AuthenticationResult) {&#10;                        super.onAuthenticationSucceeded(result)&#10;                        onResult(vaultsViewModel.getRawPassword(pw.uuid))&#10;                    }&#10;&#10;                    override fun onAuthenticationError(errorCode: Int, errString: CharSequence) {&#10;                        super.onAuthenticationError(errorCode, errString)&#10;                        onResult(null)&#10;                    }&#10;&#10;                    override fun onAuthenticationFailed() {&#10;                        super.onAuthenticationFailed()&#10;                        onResult(null)&#10;                    }&#10;                })&#10;            biometricPrompt.authenticate(promptInfo)&#10;        }&#10;    }&#10;&#10;    AddEditPasswordScreen(&#10;        password = pwToEdit,&#10;        onSave = { title, username, rawPassword -&gt;&#10;            if (pwToEdit == null) {&#10;                vaultsViewModel.addPassword(title, username, rawPassword)&#10;            } else {&#10;                vaultsViewModel.updatePassword(pwToEdit.copy(title = title, username = username), if (rawPassword.isBlank()) null else rawPassword)&#10;            }&#10;            navController.popBackStack()&#10;        },&#10;        onDelete = { pw -&gt;&#10;            vaultsViewModel.deletePassword(pw)&#10;            navController.popBackStack()&#10;        },&#10;        onNavigateUp = { navController.popBackStack() },&#10;        requestRawPassword = requestRawPassword&#10;    )&#10;}&#10;&#10;@Composable&#10;fun AddEditCardRoute(&#10;    navController: NavController,&#10;    vaultsViewModel: VaultsViewModel,&#10;    backStackEntry: NavBackStackEntry&#10;) {&#10;    val cardId = backStackEntry.arguments?.getInt(&quot;cardId&quot;)&#10;    val cardToEdit = vaultsViewModel.cards.collectAsState().value.find { it.id == cardId }&#10;    val context = LocalContext.current&#10;&#10;    val requestFullNumber: (((String?) -&gt; Unit) -&gt; Unit)? = cardToEdit?.let { card -&gt;&#10;        { onResult -&gt;&#10;            val executor = ContextCompat.getMainExecutor(context)&#10;            val promptInfo = BiometricPrompt.PromptInfo.Builder()&#10;                .setTitle(&quot;Authenticate&quot;)&#10;                .setSubtitle(&quot;Authenticate to reveal card number&quot;)&#10;                .setNegativeButtonText(&quot;Cancel&quot;)&#10;                .build()&#10;            val biometricPrompt = BiometricPrompt(context as FragmentActivity, executor,&#10;                object : BiometricPrompt.AuthenticationCallback() {&#10;                    override fun onAuthenticationSucceeded(result: BiometricPrompt.AuthenticationResult) {&#10;                        super.onAuthenticationSucceeded(result)&#10;                        onResult(vaultsViewModel.getFullNumber(card.uuid))&#10;                    }&#10;&#10;                    override fun onAuthenticationError(errorCode: Int, errString: CharSequence) {&#10;                        super.onAuthenticationError(errorCode, errString)&#10;                        onResult(null)&#10;                    }&#10;&#10;                    override fun onAuthenticationFailed() {&#10;                        super.onAuthenticationFailed()&#10;                        onResult(null)&#10;                    }&#10;                })&#10;            biometricPrompt.authenticate(promptInfo)&#10;        }&#10;    }&#10;&#10;    AddEditCardScreen(&#10;        card = cardToEdit,&#10;        onSave = { name, fullNumber, brand -&gt;&#10;            if (cardToEdit == null) {&#10;                vaultsViewModel.addCard(name, fullNumber, brand)&#10;            } else {&#10;                vaultsViewModel.updateCard(cardToEdit.copy(cardholderName = name, brand = brand), if (fullNumber.isBlank()) null else fullNumber)&#10;            }&#10;            navController.popBackStack()&#10;        },&#10;        onDelete = { c -&gt;&#10;            vaultsViewModel.deleteCard(c)&#10;            navController.popBackStack()&#10;        },&#10;        onNavigateUp = { navController.popBackStack() },&#10;        onRequestFullNumber = requestFullNumber&#10;    )&#10;}&#10;&#10;@Composable&#10;fun MainScreen(&#10;    onNavigateToAddNote: () -&gt; Unit,&#10;    onNavigateToEditNote: (Int) -&gt; Unit,&#10;    onNavigateToAddPassword: () -&gt; Unit,&#10;    onNavigateToEditPassword: (Int) -&gt; Unit,&#10;    onNavigateToAddCard: () -&gt; Unit,&#10;    onNavigateToEditCard: (Int) -&gt; Unit,&#10;    notesViewModel: NotesViewModel,&#10;    vaultsViewModel: VaultsViewModel,&#10;    activity: Activity,&#10;    backupRepository: BackupRepository,&#10;    accessTokenProvider: suspend () -&gt; String?,&#10;    onSignIn: () -&gt; Unit&#10;) {&#10;    // Specify type parameter explicitly to help inference&#10;    var currentDestination by rememberSaveable { mutableStateOf&lt;AppDestinations&gt;(AppDestinations.NOTES) }&#10;&#10;    NavigationSuiteScaffold(&#10;        navigationSuiteItems = {&#10;            AppDestinations.entries.forEach {&#10;                item(&#10;                    icon = {&#10;                        Icon(&#10;                            it.icon,&#10;                            contentDescription = it.label&#10;                        )&#10;                    },&#10;                    label = { Text(it.label) },&#10;                    selected = it == currentDestination,&#10;                    onClick = { currentDestination = it }&#10;                )&#10;            }&#10;        }&#10;    ) {&#10;        Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding -&gt;&#10;            when (currentDestination) {&#10;                AppDestinations.NOTES -&gt; NotesScreen(&#10;                    modifier = Modifier.padding(innerPadding),&#10;                    notesViewModel = notesViewModel,&#10;                    onAddNoteClicked = onNavigateToAddNote,&#10;                    onNoteClicked = onNavigateToEditNote&#10;                )&#10;                AppDestinations.PASSWORDS -&gt; VaultsScreen(&#10;                    modifier = Modifier.padding(innerPadding),&#10;                    vaultsViewModel = vaultsViewModel,&#10;                    onAddPassword = onNavigateToAddPassword,&#10;                    onAddCard = onNavigateToAddCard,&#10;                    onPasswordClick = { pw -&gt; onNavigateToEditPassword(pw.id) },&#10;                    onCardClick = { card -&gt; onNavigateToEditCard(card.id) }&#10;                )&#10;                AppDestinations.FILES -&gt; FilesScreen(modifier = Modifier.padding(innerPadding))&#10;                AppDestinations.BACKUP -&gt; BackupScreen(&#10;                    modifier = Modifier.padding(innerPadding),&#10;                    activity = activity,&#10;                    backupRepository = backupRepository,&#10;                    accessTokenProvider = accessTokenProvider,&#10;                    onSignIn = onSignIn&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun AddEditNoteRoute(&#10;    navController: NavController,&#10;    notesViewModel: NotesViewModel,&#10;    backStackEntry: NavBackStackEntry&#10;) {&#10;    val noteId = backStackEntry.arguments?.getInt(&quot;noteId&quot;)&#10;    val noteToEdit = notesViewModel.notes.collectAsState().value.find { it.id == noteId }&#10;&#10;    AddEditNoteScreen(&#10;        note = noteToEdit,&#10;        onSave = { note -&gt;&#10;            if (noteToEdit == null) {&#10;                notesViewModel.addNote(note)&#10;            } else {&#10;                notesViewModel.updateNote(note.copy(id = noteToEdit.id))&#10;            }&#10;            navController.popBackStack()&#10;        },&#10;        onDelete = { note -&gt;&#10;            notesViewModel.deleteNote(note)&#10;            navController.popBackStack()&#10;        },&#10;        onNavigateUp = { navController.popBackStack() }&#10;    )&#10;}&#10;&#10;&#10;@Composable&#10;fun NotesScreen(&#10;    modifier: Modifier = Modifier,&#10;    notesViewModel: NotesViewModel,&#10;    onAddNoteClicked: () -&gt; Unit,&#10;    onNoteClicked: (Int) -&gt; Unit&#10;) {&#10;    val notes by notesViewModel.notes.collectAsState()&#10;&#10;    Scaffold(&#10;        modifier = modifier,&#10;        floatingActionButton = {&#10;            FloatingActionButton(onClick = onAddNoteClicked) {&#10;                Icon(Icons.Filled.Add, contentDescription = &quot;Add note&quot;)&#10;            }&#10;        }&#10;    ) { innerPadding -&gt;&#10;        LazyColumn(&#10;            modifier = Modifier&#10;                .padding(innerPadding)&#10;                .padding(16.dp),&#10;            verticalArrangement = Arrangement.spacedBy(8.dp)&#10;        ) {&#10;            items(notes) { note -&gt;&#10;                NoteItem(note, onClick = { onNoteClicked(note.id) })&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun NoteItem(note: Note, onClick: () -&gt; Unit) {&#10;    Card(modifier = Modifier.clickable(onClick = onClick)) {&#10;        Column(modifier = Modifier.padding(16.dp)) {&#10;            Text(text = note.title, style = MaterialTheme.typography.titleMedium)&#10;            Text(text = note.content, style = MaterialTheme.typography.bodyMedium)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/rohit/one/data/BackupCrypto.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/rohit/one/data/BackupCrypto.kt" />
              <option name="updatedContent" value="package com.rohit.one.data&#10;&#10;import android.util.Base64&#10;import java.nio.ByteBuffer&#10;import java.security.SecureRandom&#10;import javax.crypto.Cipher&#10;import javax.crypto.SecretKeyFactory&#10;import javax.crypto.spec.GCMParameterSpec&#10;import javax.crypto.spec.PBEKeySpec&#10;import javax.crypto.spec.SecretKeySpec&#10;&#10;object BackupCrypto {&#10;    private const val AES_MODE = &quot;AES/GCM/NoPadding&quot;&#10;    private const val IV_SIZE = 12&#10;    private const val TAG_LENGTH = 128&#10;    private const val SALT_SIZE = 16&#10;    private const val ITERATIONS = 100_000&#10;    private const val KEY_LENGTH = 256&#10;&#10;    private val random = SecureRandom()&#10;&#10;    fun encryptWithPassphrase(plainText: String, passphrase: CharArray): String {&#10;        val salt = ByteArray(SALT_SIZE).also { random.nextBytes(it) }&#10;        val key = deriveKey(passphrase, salt)&#10;        val cipher = Cipher.getInstance(AES_MODE)&#10;        cipher.init(Cipher.ENCRYPT_MODE, key)&#10;        val iv = cipher.iv&#10;        val cipherBytes = cipher.doFinal(plainText.toByteArray(Charsets.UTF_8))&#10;        val byteBuffer = ByteBuffer.allocate(4 + salt.size + 4 + iv.size + cipherBytes.size)&#10;        byteBuffer.putInt(salt.size)&#10;        byteBuffer.put(salt)&#10;        byteBuffer.putInt(iv.size)&#10;        byteBuffer.put(iv)&#10;        byteBuffer.put(cipherBytes)&#10;        return Base64.encodeToString(byteBuffer.array(), Base64.NO_WRAP)&#10;    }&#10;&#10;    fun decryptWithPassphrase(encrypted: String?, passphrase: CharArray): String? {&#10;        if (encrypted == null) return null&#10;        try {&#10;            val decoded = Base64.decode(encrypted, Base64.NO_WRAP)&#10;            val bb = ByteBuffer.wrap(decoded)&#10;            val saltLen = bb.int&#10;            val salt = ByteArray(saltLen)&#10;            bb.get(salt)&#10;            val ivLen = bb.int&#10;            val iv = ByteArray(ivLen)&#10;            bb.get(iv)&#10;            val cipherBytes = ByteArray(bb.remaining())&#10;            bb.get(cipherBytes)&#10;            val key = deriveKey(passphrase, salt)&#10;            val cipher = Cipher.getInstance(AES_MODE)&#10;            val spec = GCMParameterSpec(TAG_LENGTH, iv)&#10;            cipher.init(Cipher.DECRYPT_MODE, key, spec)&#10;            val plain = cipher.doFinal(cipherBytes)&#10;            return String(plain, Charsets.UTF_8)&#10;        } catch (e: Exception) {&#10;            return null&#10;        }&#10;    }&#10;&#10;    private fun deriveKey(passphrase: CharArray, salt: ByteArray): SecretKeySpec {&#10;        val spec = PBEKeySpec(passphrase, salt, ITERATIONS, KEY_LENGTH)&#10;        val skf = SecretKeyFactory.getInstance(&quot;PBKDF2WithHmacSHA256&quot;)&#10;        val keyBytes = skf.generateSecret(spec).encoded&#10;        return SecretKeySpec(keyBytes, &quot;AES&quot;)&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/rohit/one/data/BackupRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/rohit/one/data/BackupRepository.kt" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="package com.rohit.one.data&#10;&#10;import android.content.Context&#10;import com.squareup.moshi.Moshi&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.withContext&#10;import okhttp3.MediaType.Companion.toMediaType&#10;import okhttp3.MultipartBody&#10;import okhttp3.OkHttpClient&#10;import okhttp3.Request&#10;import okhttp3.RequestBody&#10;&#10;class BackupRepository(private val context: Context) {&#10;&#10;    private val client = OkHttpClient()&#10;    private val moshi = Moshi.Builder().build()&#10;&#10;    suspend fun createEncryptedBackup(jsonPayload: String): String = withContext(Dispatchers.IO) {&#10;        CryptoUtil.encrypt(jsonPayload)&#10;    }&#10;&#10;    suspend fun decryptBackup(encrypted: String): String? = withContext(Dispatchers.IO) {&#10;        CryptoUtil.decrypt(encrypted)&#10;    }&#10;&#10;    suspend fun createPassphraseBackup(jsonPayload: String, passphrase: CharArray): String = withContext(Dispatchers.IO) {&#10;        BackupCrypto.encryptWithPassphrase(jsonPayload, passphrase)&#10;    }&#10;&#10;    suspend fun decryptPassphraseBackup(encrypted: String, passphrase: CharArray): String? = withContext(Dispatchers.IO) {&#10;        BackupCrypto.decryptWithPassphrase(encrypted, passphrase)&#10;    }&#10;&#10;    // Upload to Drive appData via simple REST call. Caller must supply a valid OAuth access token&#10;    suspend fun uploadBackupToDrive(encryptedPayload: String, accessToken: String): Boolean = withContext(Dispatchers.IO) {&#10;        val url = &quot;https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart&amp;fields=id&quot;&#10;        val metadataJson = &quot;{\&quot;name\&quot;: \&quot;one_backup.json.enc\&quot;, \&quot;parents\&quot;: [\&quot;appDataFolder\&quot;]}&quot;&#10;&#10;        val metadataBody = RequestBody.create(&quot;application/json; charset=utf-8&quot;.toMediaType(), metadataJson)&#10;        val fileBody = RequestBody.create(&quot;application/octet-stream&quot;.toMediaType(), encryptedPayload.toByteArray(Charsets.UTF_8))&#10;&#10;        val multipart = MultipartBody.Builder().setType(MultipartBody.FORM)&#10;            .addFormDataPart(&quot;metadata&quot;, null, metadataBody)&#10;            .addFormDataPart(&quot;file&quot;, &quot;one_backup.json.enc&quot;, fileBody)&#10;            .build()&#10;&#10;        val request = Request.Builder()&#10;            .url(url)&#10;            .addHeader(&quot;Authorization&quot;, &quot;Bearer $accessToken&quot;)&#10;            .post(multipart)&#10;            .build()&#10;&#10;        client.newCall(request).execute().use { resp -&gt;&#10;            return@withContext resp.isSuccessful&#10;        }&#10;    }&#10;&#10;    // Download the latest backup file from appDataFolder. Caller must provide an access token.&#10;    suspend fun downloadLatestBackupFromDrive(accessToken: String): String? = withContext(Dispatchers.IO) {&#10;        val listUrl = &quot;https://www.googleapis.com/drive/v3/files?q=name=%27one_backup.json.enc%27+and+parents+in+appDataFolder&amp;spaces=appDataFolder&amp;fields=files(id,name,createdTime)&amp;orderBy=createdTime desc&amp;pageSize=1&quot;&#10;        val listReq = Request.Builder()&#10;            .url(listUrl)&#10;            .addHeader(&quot;Authorization&quot;, &quot;Bearer $accessToken&quot;)&#10;            .get()&#10;            .build()&#10;&#10;        client.newCall(listReq).execute().use { listResp -&gt;&#10;            if (!listResp.isSuccessful) return@withContext null&#10;            val body = listResp.body?.string() ?: return@withContext null&#10;            val jsonAdapter = moshi.adapter(Map::class.java)&#10;            val parsed = jsonAdapter.fromJson(body) as? Map&lt;*, *&gt; ?: return@withContext null&#10;            val files = parsed[&quot;files&quot;] as? List&lt;*&gt; ?: return@withContext null&#10;            if (files.isEmpty()) return@withContext null&#10;            val first = files[0] as? Map&lt;*, *&gt; ?: return@withContext null&#10;            val id = first[&quot;id&quot;] as? String ?: return@withContext null&#10;&#10;            val downloadUrl = &quot;https://www.googleapis.com/drive/v3/files/$id?alt=media&quot;&#10;            val dlReq = Request.Builder()&#10;                .url(downloadUrl)&#10;                .addHeader(&quot;Authorization&quot;, &quot;Bearer $accessToken&quot;)&#10;                .get()&#10;                .build()&#10;&#10;            client.newCall(dlReq).execute().use { dlResp -&gt;&#10;                if (!dlResp.isSuccessful) return@withContext null&#10;                return@withContext dlResp.body?.string()&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/rohit/one/ui/BackupScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/rohit/one/ui/BackupScreen.kt" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="@file:OptIn(androidx.compose.material3.ExperimentalMaterial3Api::class)&#10;package com.rohit.one.ui&#10;&#10;import android.app.Activity&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.material3.TopAppBar&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;import com.rohit.one.data.BackupRepository&#10;import kotlinx.coroutines.launch&#10;&#10;@Composable&#10;fun BackupScreen(&#10;    activity: Activity,&#10;    backupRepository: BackupRepository,&#10;    accessTokenProvider: suspend () -&gt; String?,&#10;    onSignIn: () -&gt; Unit&#10;) {&#10;    val scope = rememberCoroutineScope()&#10;&#10;    Scaffold(&#10;        topBar = { TopAppBar(title = { Text(&quot;Backup / Restore&quot;) }) }&#10;    ) { inner -&gt;&#10;        Column(modifier = Modifier.padding(inner).padding(16.dp).fillMaxSize()) {&#10;            Button(onClick = { onSignIn() }) {&#10;                Text(&quot;Sign in to Google&quot;)&#10;            }&#10;&#10;            Button(onClick = {&#10;                scope.launch {&#10;                    val token = accessTokenProvider()&#10;                    if (token == null) return@launch&#10;                    // gather data from app (notes, passwords, cards) - placeholder&#10;                    val payload = &quot;{\&quot;notes\&quot;:[], \&quot;passwords\&quot;:[], \&quot;cards\&quot;:[]}&quot;&#10;                    val enc = backupRepository.createEncryptedBackup(payload)&#10;                    val ok = backupRepository.uploadBackupToDrive(enc, token)&#10;                    // show result - left as an exercise to implement Snackbar&#10;                }&#10;            }) {&#10;                Text(&quot;Backup now&quot;)&#10;            }&#10;&#10;            Button(onClick = {&#10;                scope.launch {&#10;                    val token = accessTokenProvider()&#10;                    if (token == null) return@launch&#10;                    val enc = backupRepository.downloadLatestBackupFromDrive(token)&#10;                    val json = enc?.let { backupRepository.decryptBackup(it) }&#10;                    // parse JSON and restore - left as exercise&#10;                }&#10;            }) {&#10;                Text(&quot;Restore latest backup&quot;)&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>